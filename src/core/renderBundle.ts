import Ajv, { type ValidateFunction } from 'ajv';
import JSZip from 'jszip';
import nunjucks from 'nunjucks';
import yaml from 'js-yaml';

import configSchema from '../../schemas/config.schema.json' assert { type: 'json' };
import { defaultTemplates, type TemplateSet } from './templates.js';

export type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };
export type JsonObject = { [key: string]: JsonValue };

export interface NotebookCell {
  cell_type: string;
  source: string[] | string;
  metadata?: Record<string, unknown>;
  execution_count?: number | null;
  outputs?: unknown[];
  [key: string]: unknown;
}

export interface NotebookDocument {
  nbformat: number;
  nbformat_minor: number;
  metadata: Record<string, unknown>;
  cells: NotebookCell[];
  [key: string]: unknown;
}

export interface RenderBundleOptions {
  timestamp?: Date;
  createZip?: boolean;
  templates?: Partial<TemplateSet>;
}

export interface RenderedArtifacts {
  notebookObject: NotebookDocument;
  notebookJson: string;
  readmeMarkdown: string;
  configYaml: string;
  zipData?: Uint8Array;
}

class ConfigValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ConfigValidationError';
  }
}

const ajv = new Ajv({
  allErrors: true,
  strict: false
});

let compiledValidator: ValidateFunction<JsonObject> | null = null;

const nunjucksEnv = new nunjucks.Environment(undefined, {
  autoescape: false,
  trimBlocks: true,
  lstripBlocks: true
});

nunjucksEnv.addFilter('newline_join', (value: string | string[]) => {
  if (Array.isArray(value)) {
    return value.join('\n');
  }
  return value;
});

export async function renderBundle(
  rawConfig: JsonValue,
  options: RenderBundleOptions = {}
): Promise<RenderedArtifacts> {
  if (rawConfig === null || typeof rawConfig !== 'object' || Array.isArray(rawConfig)) {
    throw new ConfigValidationError('Config must be a JSON object at the root level.');
  }

  const config = rawConfig as JsonObject;
  const timestamp = options.timestamp ?? new Date();
  const templates: TemplateSet = {
    ...defaultTemplates,
    ...(options.templates ?? {})
  };

  validateConfig(config);

  const configYaml = yaml.dump(config, { noRefs: true, lineWidth: 120 });
  const templateContext = {
    config,
    generated_at_iso: timestamp.toISOString(),
    config_json_pretty: JSON.stringify(config, null, 2),
    config_yaml: configYaml
  };

  const notebookRendered = nunjucksEnv.renderString(templates.notebook, templateContext);
  const readmeRendered = nunjucksEnv.renderString(templates.readme, templateContext).trimEnd() + '\n';
  const configRendered = nunjucksEnv.renderString(templates.config, templateContext).trimEnd() + '\n';

  const notebookObject = parseNotebookTemplate(notebookRendered);
  embedConfigCell(notebookObject, config, timestamp);

  const notebookJson = JSON.stringify(notebookObject, null, 2);

  let zipData: Uint8Array | undefined;
  if (options.createZip ?? true) {
    const zip = new JSZip();
    zip.file('fine_tune.ipynb', notebookJson);
    zip.file('config.yaml', configRendered);
    zip.file('README.md', readmeRendered);
    zipData = await zip.generateAsync({
      type: 'uint8array',
      compression: 'DEFLATE',
      compressionOptions: { level: 6 }
    });
  }

  return {
    notebookObject,
    notebookJson,
    readmeMarkdown: readmeRendered,
    configYaml: configRendered,
    zipData
  };
}

function validateConfig(config: JsonObject): void {
  if (!compiledValidator) {
    compiledValidator = ajv.compile<JsonObject>(configSchema as JsonObject);
  }

  const valid = compiledValidator(config);
  if (!valid) {
    const errors = (compiledValidator.errors ?? [])
      .map((err) => `${err.instancePath || '/'} ${err.message}`)
      .join('; ');
    throw new ConfigValidationError(`Config validation failed: ${errors}`);
  }
}

function parseNotebookTemplate(serialized: string): NotebookDocument {
  try {
    return JSON.parse(serialized) as NotebookDocument;
  } catch (err) {
    throw new Error(`Failed to parse notebook template as JSON: ${(err as Error).message}`);
  }
}

function embedConfigCell(
  notebook: NotebookDocument,
  config: JsonObject,
  timestamp: Date
): void {
  const configCell =
    notebook.cells.find(
      (cell) =>
        cell.cell_type === 'code' &&
        hasTag(cell, 'config')
    ) ?? createAndAppendConfigCell(notebook);

  const lines = buildConfigCellSource(config, timestamp);
  configCell.source = toNotebookSourceArray(lines);
  configCell.metadata = {
    ...(configCell.metadata ?? {}),
    tags: Array.from(
      new Set([...(Array.isArray(configCell.metadata?.tags) ? (configCell.metadata?.tags as string[]) : []), 'config'])
    ),
    autogenerated: true
  };
}

function createAndAppendConfigCell(notebook: NotebookDocument): NotebookCell {
  const newCell: NotebookCell = {
    cell_type: 'code',
    execution_count: null,
    metadata: { tags: ['config'] },
    outputs: [],
    source: []
  };
  notebook.cells.unshift(newCell);
  return newCell;
}

function buildConfigCellSource(
  config: JsonObject,
  timestamp: Date
): string[] {
  const prettyConfig = JSON.stringify(config, null, 2).split('\n');
  const lines: string[] = [
    '# Generated configuration payload.',
    'from __future__ import annotations',
    '',
    `CONFIG_GENERATED_AT = "${timestamp.toISOString()}"`,
    'CONFIG = ' + (prettyConfig.shift() ?? '{}')
  ];

  for (const line of prettyConfig) {
    lines.push(line);
  }

  lines.push('');
  lines.push('print("Loaded config with provider:", CONFIG.get("provider"))');
  return lines;
}

function hasTag(cell: NotebookCell, tag: string): boolean {
  const tags = cell.metadata?.tags;
  if (!Array.isArray(tags)) {
    return false;
  }
  return tags.includes(tag);
}

function toNotebookSourceArray(lines: string[]): string[] {
  return lines.map((line, idx) => (idx === lines.length - 1 ? line : `${line}\n`));
}
